

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Meta Machine Learning &mdash; REP (Reproducible Experiment Platform) 0.6.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="REP (Reproducible Experiment Platform) 0.6.2 documentation" href="index.html"/>
        <link rel="next" title="Report for models" href="report.html"/>
        <link rel="prev" title="Estimators (classification and regression)" href="estimators.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> REP (Reproducible Experiment Platform)
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="estimators.html">Estimators (classification and regression)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Meta Machine Learning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.factory">Factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#factory-examples">Factory Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.gridsearch">Grid Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.folding">Folding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-rep.metaml.stacking">Stacking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="report.html">Report for models</a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference external" href="http://nbviewer.ipython.org/github/yandex/rep/tree/master/howto/">Howto notebooks</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">REP (Reproducible Experiment Platform)</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Meta Machine Learning</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/metaml.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="meta-machine-learning">
<span id="metaml"></span><h1>Meta Machine Learning<a class="headerlink" href="#meta-machine-learning" title="Permalink to this headline">¶</a></h1>
<p>Meta machine learning is specific algorithms, like complicated hierarchical algorithm, hyperparameters optimization parameters.
Also there is Factory which allows you to train set of models and compare them very simply.</p>
<div class="section" id="module-rep.metaml.factory">
<span id="factory"></span><h2>Factory<a class="headerlink" href="#module-rep.metaml.factory" title="Permalink to this headline">¶</a></h2>
<p><strong>Factory</strong> provides convenient way to train several classifiers on the same dataset.
These classifiers can be trained one-by-one in a single thread, or simultaneously</p>
<blockquote>
<div>with IPython cluster or in several threads.</div></blockquote>
<p>Also <cite>Factory</cite> allows comparison of several classifiers (predictions of which can be used in parallel).</p>
<dl class="class">
<dt id="rep.metaml.factory.AbstractFactory">
<em class="property">class </em><code class="descclassname">rep.metaml.factory.</code><code class="descname">AbstractFactory</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></p>
<p>Factory provides interface to train simultaneously several estimators (classifiers or regressors).
Later their quality can be compared.</p>
<blockquote>
<div></div></blockquote>
<dl class="method">
<dt id="rep.metaml.factory.AbstractFactory.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em>, <em>parallel_profile=None</em>, <em>features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Train all estimators on the same data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features] with features</li>
<li><strong>y</strong> &#8211; array-like of shape [n_samples] with labels of samples</li>
<li><strong>sample_weight</strong> &#8211; weights of events,
array-like of shape [n_samples] or None if all weights are equal</li>
<li><strong>features</strong> (<em>None or list[str]</em>) &#8211; features to train estimators
If None, estimators will be trained on <cite>estimator.features</cite></li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile of parallel execution system or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.AbstractFactory.fit_lds">
<code class="descname">fit_lds</code><span class="sig-paren">(</span><em>lds</em>, <em>parallel_profile=None</em>, <em>features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory.fit_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory.fit_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit all estimators on the same dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; dataset</li>
<li><strong>features</strong> &#8211; features to train estimators
If None, estimators will be trained on <cite>estimator.features</cite></li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile of parallel execution system or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.AbstractFactory.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels (or values for regressors) for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile of parallel execution system or None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with integer labels (or values)]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.AbstractFactory.test_on">
<code class="descname">test_on</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory.test_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory.test_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare report for factory (comparison of all models).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features] with features</li>
<li><strong>y</strong> &#8211; numpy.array of shape [n_samples] with targets</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">rep.report.classification.ClassificationReport or rep.report.regression.RegressionReport</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.AbstractFactory.test_on_lds">
<code class="descname">test_on_lds</code><span class="sig-paren">(</span><em>lds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#AbstractFactory.test_on_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.AbstractFactory.test_on_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare report for factory (comparison of all models).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">rep.report.classification.ClassificationReport or rep.report.regression.RegressionReport</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.factory.ClassifiersFactory">
<em class="property">class </em><code class="descclassname">rep.metaml.factory.</code><code class="descname">ClassifiersFactory</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.factory.AbstractFactory" title="rep.metaml.factory.AbstractFactory"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.factory.AbstractFactory</span></code></a></p>
<p>Factory provides training of several classifiers in parallel.
Quality of trained classifiers can be compared.</p>
<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.add_classifier">
<code class="descname">add_classifier</code><span class="sig-paren">(</span><em>name</em>, <em>classifier</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.add_classifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.add_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Add classifier to factory.
Automatically wraps classifier with <code class="xref py py-class docutils literal"><span class="pre">SklearnClassifier</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; unique name for classifier.
If name coincides with one already used, the old classifier will be replaced by one passed.</li>
<li><strong>classifier</strong> (<em>sklearn.base.BaseEstimator or estimators.interface.Classifier</em>) &#8211; <p>classifier object</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if type == sklearn.base.BaseEstimator, then features=None is used,</p>
</div>
<p>to specify features used by classifier, wrap it with <cite>SklearnClassifier</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile for IPython cluster</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with integer labels]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with float predictions]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.staged_predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities on each stage (attention: returns dictionary of generators)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict[iterator]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.ClassifiersFactory.test_on_lds">
<code class="descname">test_on_lds</code><span class="sig-paren">(</span><em>lds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#ClassifiersFactory.test_on_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.ClassifiersFactory.test_on_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare report for factory of estimators</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="report.html#rep.report.classification.ClassificationReport" title="rep.report.classification.ClassificationReport">rep.report.classification.ClassificationReport</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.factory.RegressorsFactory">
<em class="property">class </em><code class="descclassname">rep.metaml.factory.</code><code class="descname">RegressorsFactory</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.factory.AbstractFactory" title="rep.metaml.factory.AbstractFactory"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.factory.AbstractFactory</span></code></a></p>
<p>Factory provides training of several classifiers in parallel.
Quality of trained regressors can be compared.</p>
<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.add_regressor">
<code class="descname">add_regressor</code><span class="sig-paren">(</span><em>name</em>, <em>regressor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.add_regressor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.add_regressor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add regressor to factory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; unique name for regressor.
If name coincides with one already used, the old regressor will be replaced by one passed.</li>
<li><strong>regressor</strong> (<em>sklearn.base.BaseEstimator or estimators.interface.Regressor</em>) &#8211; <p>regressor object</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if type == sklearn.base.BaseEstimator, then features=None is used</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict values for all events in dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>parallel_profile</strong> (<em>None or name of profile to parallelize computations.</em>) &#8211; profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">OrderedDict[numpy.array of shape [n_samples] with float values]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.staged_predict">
<code class="descname">staged_predict</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.staged_predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.staged_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicts probabilities on each stage</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">dict[iterator]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.factory.RegressorsFactory.test_on_lds">
<code class="descname">test_on_lds</code><span class="sig-paren">(</span><em>lds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#RegressorsFactory.test_on_lds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.RegressorsFactory.test_on_lds" title="Permalink to this definition">¶</a></dt>
<dd><p>Report for factory of estimators</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lds</strong> (<a class="reference internal" href="data.html#rep.data.storage.LabeledDataStorage" title="rep.data.storage.LabeledDataStorage"><em>LabeledDataStorage</em></a>) &#8211; data</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="report.html#rep.report.regression.RegressionReport" title="rep.report.regression.RegressionReport">rep.report.regression.RegressionReport</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="rep.metaml.factory.predict_estimator">
<code class="descclassname">rep.metaml.factory.</code><code class="descname">predict_estimator</code><span class="sig-paren">(</span><em>name</em>, <em>estimator</em>, <em>X</em>, <em>prediction_type='classification'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#predict_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.predict_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Supplementary function.
Builds predictions for one estimator on a separate node (or in a separate thread)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; classifier name</li>
<li><strong>estimator</strong> (<em>Classifier or Regressor</em>) &#8211; estimator</li>
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>prediction_type</strong> (<em>str</em>) &#8211; &#8216;classification&#8217; or &#8216;regression&#8217; or &#8216;classification-proba&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(&#8216;success&#8217;, (name (str), probabilities (numpy.array), time (int) )) or
(&#8216;fail&#8217;, (name (str), pid (int), socket (int), error (Exception) ))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="rep.metaml.factory.train_estimator">
<code class="descclassname">rep.metaml.factory.</code><code class="descname">train_estimator</code><span class="sig-paren">(</span><em>name</em>, <em>estimator</em>, <em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/factory.html#train_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.factory.train_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Supplementary function.
Trains estimator on a separate node (or in a separate thread)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; classifier name</li>
<li><strong>estimator</strong> (<em>Classifier or Regressor</em>) &#8211; estimator</li>
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(&#8216;success&#8217;, (name (str), estimator (Classifier or Regressor), time (int) )) or
(&#8216;fail&#8217;, (name (str), pid (int), socket (int), error (Exception) ))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="factory-examples">
<h2>Factory Examples<a class="headerlink" href="#factory-examples" title="Permalink to this headline">¶</a></h2>
<ul>
<li><dl class="first docutils">
<dt>Prepare dataset</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span><span class="o">,</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.utils</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># iris data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Take just two classes instead of three</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">labels</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_data</span><span class="p">,</span> <span class="n">test_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Train factory of classifiers</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.metaml</span> <span class="kn">import</span> <span class="n">ClassifiersFactory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rep.estimators</span> <span class="kn">import</span> <span class="n">TMVAClassifier</span><span class="p">,</span> <span class="n">SklearnClassifier</span><span class="p">,</span> <span class="n">XGBoostClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span> <span class="o">=</span> <span class="n">ClassifiersFactory</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">add_classifier</span><span class="p">(</span><span class="s">&#39;tmva&#39;</span><span class="p">,</span> <span class="n">TMVAClassifier</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;kBDT&#39;</span><span class="p">,</span> <span class="n">NTrees</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">Shrinkage</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">nCuts</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">BoostType</span><span class="o">=</span><span class="s">&#39;Grad&#39;</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">add_classifier</span><span class="p">(</span><span class="s">&#39;ada&#39;</span><span class="p">,</span> <span class="n">GradientBoostingClassifier</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="p">[</span><span class="s">&#39;xgb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XGBoostClassifier</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">)</span>
<span class="go">model ef           was trained in 0.22 seconds</span>
<span class="go">model tmva         was trained in 2.47 seconds</span>
<span class="go">model ada          was trained in 0.02 seconds</span>
<span class="go">model xgb          was trained in 0.01 seconds</span>
<span class="go">Totally spent 2.71 seconds on training</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
<span class="go">data was predicted by tmva         in 0.02 seconds</span>
<span class="go">data was predicted by ada          in 0.00 seconds</span>
<span class="go">data was predicted by xgb          in 0.00 seconds</span>
<span class="go">Totally spent 0.05 seconds on prediction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pred</span>
<span class="go">OrderedDict([(&#39;tmva&#39;, array([[  9.98732217e-01,   1.26778255e-03], [  9.99649503e-01,   3.50497149e-04], ..])),</span>
<span class="go">             (&#39;ada&#39;, array([[  9.99705117e-01,   2.94883265e-04], [  9.99705117e-01,   2.94883265e-04], ..])),</span>
<span class="go">             (&#39;xgb&#39;, array([[  9.91589248e-01,   8.41078255e-03], ..], dtype=float32))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">pred</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">test_labels</span><span class="p">,</span> <span class="n">pred</span><span class="p">[</span><span class="n">key</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">tmva 0.933035714286</span>
<span class="go">ada 1.0</span>
<span class="go">xgb 0.995535714286</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="module-rep.metaml.gridsearch">
<span id="grid-search"></span><h2>Grid Search<a class="headerlink" href="#module-rep.metaml.gridsearch" title="Permalink to this headline">¶</a></h2>
<p>This module does hyper parameters optimization &#8211; find the best parameters for estimator using different optimization models.</p>
<dl class="class">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">AbstractParameterGenerator</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract class for grid search algorithm.
The aim of this class is to generate new points, where the function (estimator) will be computed.
You can define your own algorithm of step location of parameters grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>After the model was trained and evaluated for specific set of parameters,
we use this function to store result
:param state_indices: tuple, which represents the space
:param value: quality at this point</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.generate_batch_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate several points in parameter space at once (needed when using parallel computations)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; how many points we shall generate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sequence of tuples, each tuple representing it&#8217;s own</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AbstractParameterGenerator.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AbstractParameterGenerator.print_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AbstractParameterGenerator.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">AnnealingParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>temperature=0.2</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>After the model was trained and evaluated for specific set of parameters,
we use this function to store result
:param state_indices: tuple, which represents the space
:param value: quality at this point</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer.generate_batch_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#AnnealingParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.AnnealingParameterOptimizer.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.AnnealingParameterOptimizer.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.FoldingScorer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">FoldingScorer</code><span class="sig-paren">(</span><em>score_function</em>, <em>folds=3</em>, <em>fold_checks=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#FoldingScorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.FoldingScorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Scorer, which implements logic of data folding and scoring. This is a function-like object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>folds</strong> (<em>int</em>) &#8211; &#8216;k&#8217; used in k-folding while validating</li>
<li><strong>fold_checks</strong> (<em>int</em>) &#8211; not greater than folds, the number of checks we do by cross-validating</li>
<li><strong>score_function</strong> (<em>function</em>) &#8211; quality. if fold_checks &gt; 1, the average is computed over checks.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">new_score_function</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">proba</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    y_true: [n_samples]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    proba: [n_samples, n_classes]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    sample_weight: [n_samples] or None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">FoldingScorer</span><span class="p">(</span><span class="n">new_score_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">GridOptimalSearchCV</code><span class="sig-paren">(</span><em>estimator</em>, <em>params_generator</em>, <em>scorer</em>, <em>parallel_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Optimal search over specified parameter values for an estimator. Metropolis-like algorithm is used
Important members are fit, scorer.</p>
<p>GridSearchCV implements a &#8220;fit&#8221; method and a &#8220;fit_best_estimator&#8221; method to train models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>estimator</strong> (<em>BaseEstimator</em>) &#8211; object of type that implements the &#8220;fit&#8221; and &#8220;fit_best_estimator&#8221; methods
A new object of that type is cloned for each point.</li>
<li><strong>params_generator</strong> (<a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><em>AbstractParameterGenerator</em></a>) &#8211; generator of grid search algorithm</li>
<li><strong>scorer</strong> (<em>object</em>) &#8211; which implement method __call__ with kwargs:
&#8220;base_estimator&#8221;, &#8220;params&#8221;, &#8220;X&#8221;, &#8220;y&#8221;, &#8220;sample_weight&#8221;</li>
<li><strong>parallel_profile</strong> (<em>None or str</em>) &#8211; name of profile</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>generator: return grid generator</p>
<dl class="method">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run fit with all sets of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; array-like, shape = [n_samples, n_features]
Training vector, where n_samples is the number of samples and n_features is the number of features.</li>
<li><strong>y</strong> &#8211; array-like, shape = [n_samples] or [n_samples, n_output], optional</li>
<li><strong>sample_weight</strong> &#8211; array-like, shape = [n_samples], weight</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.fit_best_estimator">
<code class="descname">fit_best_estimator</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#GridOptimalSearchCV.fit_best_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.fit_best_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Train estimator with the best parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the best estimator</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.GridOptimalSearchCV.generator">
<code class="descname">generator</code><a class="headerlink" href="#rep.metaml.gridsearch.GridOptimalSearchCV.generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Property for params_generator</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">RandomParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RandomParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>Random generation of new grid point.</p>
<dl class="method">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>After the model was trained and evaluated for specific set of parameters,
we use this function to store result
:param state_indices: tuple, which represents the space
:param value: quality at this point</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate several points in parameter space at once (needed when using parallel computations)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; how many points we shall generate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sequence of tuples, each tuple representing it&#8217;s own</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RandomParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RandomParameterOptimizer.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RandomParameterOptimizer.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">RegressionParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em>, <em>start_evaluations=3</em>, <em>n_attempts=5</em>, <em>regressor=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RegressionParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>To generate next point of grid regressor will be used to estimate score for all next point in such way
that the point with the best estimated score will be chosen</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
<li><strong>start_evaluations</strong> (<em>int</em>) &#8211; count of random point generation on start</li>
<li><strong>n_attempts</strong> (<em>int</em>) &#8211; </li>
<li><strong>regressor</strong> &#8211; regressor to choose appropriate next point with potential best score
(estimated this score by regressor); If None them RandomForest algorithm will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>After the model was trained and evaluated for specific set of parameters,
we use this function to store result
:param state_indices: tuple, which represents the space
:param value: quality at this point</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate several points in parameter space at once (needed when using parallel computations)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; how many points we shall generate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sequence of tuples, each tuple representing it&#8217;s own</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#RegressionParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next random point in parameters space</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.RegressionParameterOptimizer.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.RegressionParameterOptimizer.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer">
<em class="property">class </em><code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">SubgridParameterOptimizer</code><span class="sig-paren">(</span><em>param_grid</em>, <em>n_evaluations=10</em>, <em>random_state=None</em>, <em>start_evaluations=3</em>, <em>subgrid_size=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#rep.metaml.gridsearch.AbstractParameterGenerator" title="rep.metaml.gridsearch.AbstractParameterGenerator"><code class="xref py py-class docutils literal"><span class="pre">rep.metaml.gridsearch.AbstractParameterGenerator</span></code></a></p>
<p>Uses Metropolis-like optimization.
If the parameter grid is large, first performs optimization on subgrid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>param_grid</strong> (<em>OrderedDict</em>) &#8211; the grid with parameters to optimize on</li>
<li><strong>n_evaluations</strong> (<em>int</em>) &#8211; the number of evaluations to do</li>
<li><strong>random_state</strong> (<em>int or RandomState or None</em>) &#8211; random generator</li>
<li><strong>start_evaluations</strong> (<em>int</em>) &#8211; count of random point generation on start</li>
<li><strong>subgrid_size</strong> (<em>int</em>) &#8211; if the size of mesh too large, first we will optimize
on subgrid with not more then subgrid_size possible values for each parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>state_indices</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.add_result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.best_params_">
<code class="descname">best_params_</code><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.best_params_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return point of parameters grid with the best score</p>
</dd></dl>

<dl class="attribute">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.best_score_">
<code class="descname">best_score_</code><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.best_score_" title="Permalink to this definition">¶</a></dt>
<dd><p>Property, return best score of optimization</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.generate_batch_points">
<code class="descname">generate_batch_points</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.generate_batch_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate several points in parameter space at once (needed when using parallel computations)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; how many points we shall generate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">sequence of tuples, each tuple representing it&#8217;s own</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.generate_next_point">
<code class="descname">generate_next_point</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#SubgridParameterOptimizer.generate_next_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.generate_next_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating next point in parameters space</p>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.gridsearch.SubgridParameterOptimizer.print_results">
<code class="descname">print_results</code><span class="sig-paren">(</span><em>reorder=True</em><span class="sig-paren">)</span><a class="headerlink" href="#rep.metaml.gridsearch.SubgridParameterOptimizer.print_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the results of training</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reorder</strong> (<em>bool</em>) &#8211; if reorder==True, best results go earlier,
otherwise the results are printed in the order of computation</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="rep.metaml.gridsearch.apply_scorer">
<code class="descclassname">rep.metaml.gridsearch.</code><code class="descname">apply_scorer</code><span class="sig-paren">(</span><em>scorer</em>, <em>params</em>, <em>base_estimator</em>, <em>X</em>, <em>y</em>, <em>sample_weight</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/gridsearch.html#apply_scorer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.gridsearch.apply_scorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Application of scorer algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>scorer</strong> &#8211; algorithm to train estimator and get quality (see FoldingScorer for example)</li>
<li><strong>params</strong> (<em>dict</em>) &#8211; parameters for estimator</li>
<li><strong>base_estimator</strong> (<em>base.BaseEstimator</em>) &#8211; estimator</li>
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features], data</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(&#8216;success&#8217;, float) or (&#8216;fail&#8217;, Exception), float will contain result.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-rep.metaml.folding">
<span id="folding"></span><h2>Folding<a class="headerlink" href="#module-rep.metaml.folding" title="Permalink to this headline">¶</a></h2>
<p>This is specific meta-algorithm based on the idea of cross-validation.</p>
<dl class="class">
<dt id="rep.metaml.folding.FoldingClassifier">
<em class="property">class </em><code class="descclassname">rep.metaml.folding.</code><code class="descname">FoldingClassifier</code><span class="sig-paren">(</span><em>base_estimator</em>, <em>n_folds=2</em>, <em>random_state=None</em>, <em>features=None</em>, <em>ipc_profile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="estimators.html#rep.estimators.interface.Classifier" title="rep.estimators.interface.Classifier"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.interface.Classifier</span></code></a></p>
<p>This meta-classifier implements folding algorithm:</p>
<ul class="simple">
<li>training data is splitted into n equal parts;</li>
<li>then n times union of n-1 parts is used to train classifier;</li>
<li>at the end we have n-estimators, which are used to classify new events</li>
</ul>
<p>To build unbiased predictions for data, pass the <strong>same</strong> dataset (with same order of events)
as in training to <cite>predict</cite>, <cite>predict_proba</cite> or <cite>staged_predict_proba</cite>, in which case
classifier will use to predict each event that base classifier which didn&#8217;t use that event during training.</p>
<p>To use information from not one, but several classifiers during predictions,
provide appropriate voting function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>base_estimator</strong> (<em>sklearn.BaseEstimator</em>) &#8211; base classifier, which will be used for training</li>
<li><strong>n_folds</strong> (<em>int</em>) &#8211; count of folds</li>
<li><strong>features</strong> (<em>None or list[str]</em>) &#8211; features used in training</li>
<li><strong>ipc_profile</strong> (<em>None or str</em>) &#8211; profile for IPython cluster, None to compute locally.</li>
<li><strong>random_state</strong> (<em>None or int or RandomState</em>) &#8211; random state for reproducibility</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the classifier, will train several base classifiers on overlapping
subsets of training dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>y</strong> &#8211; labels of events - array-like of shape [n_samples]</li>
<li><strong>sample_weight</strong> &#8211; weight of events,
array-like of shape [n_samples] or None if all weights are equal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels. To get unbiased predictions, you can pass training dataset
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function, if None, will use folding scheme.</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then folding scheme is used. Parameters: numpy.ndarray [n_classifiers, n_samples]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array of shape [n_samples, n_classes] with labels</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier.predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities. To get unbiased predictions, you can pass training dataset
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then self.vote_function is used. Parameters: numpy.ndarray [n_classifiers, n_samples, n_classes]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array of shape [n_samples, n_classes] with probabilities</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.folding.FoldingClassifier.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>vote_function=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/folding.html#FoldingClassifier.staged_predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.folding.FoldingClassifier.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities on each stage. To get unbiased predictions, you can pass training dataset
(with same order of events) and vote_function=None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</li>
<li><strong>vote_function</strong> (<em>None or function</em>) &#8211; function to combine prediction of folds&#8217; estimators.
If None then self.vote_function is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">iterator for numpy.array of shape [n_samples, n_classes] with probabilities</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-rep.metaml.stacking">
<span id="stacking"></span><h2>Stacking<a class="headerlink" href="#module-rep.metaml.stacking" title="Permalink to this headline">¶</a></h2>
<p>This module contains stacking strategies (meta-algorithms of machine learning).</p>
<dl class="class">
<dt id="rep.metaml.stacking.FeatureSplitter">
<em class="property">class </em><code class="descclassname">rep.metaml.stacking.</code><code class="descname">FeatureSplitter</code><span class="sig-paren">(</span><em>split_feature</em>, <em>base_estimator</em>, <em>train_features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="estimators.html#rep.estimators.interface.Classifier" title="rep.estimators.interface.Classifier"><code class="xref py py-class docutils literal"><span class="pre">rep.estimators.interface.Classifier</span></code></a></p>
<p>Dataset is split by values of <cite>split_feature</cite>,
for each value of feature, new classifier is trained.</p>
<p>When building predictions, classifier predicts the events with
the same value of <cite>split_feature</cite> it was trained on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>split_feature</strong> (<em>str</em>) &#8211; the name of key feature,</li>
<li><strong>base_estimator</strong> &#8211; the classifier, its&#8217; copies are trained on parts of dataset</li>
<li><strong>features</strong> (<em>list[str]</em>) &#8211; list of columns classifier uses</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>split_feature</cite> must be in list of <cite>features</cite></p>
</div>
<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features] with features</li>
<li><strong>y</strong> &#8211; array-like of shape [n_samples] with targets</li>
<li><strong>sample_weight</strong> &#8211; array-like of shape [n_samples] with events weights or None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Predict probabilities. Each event will be predicted by the classifier</dt>
<dd>with trained on corresponding value of <cite>split_feature</cite></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">probabilities of shape [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="rep.metaml.stacking.FeatureSplitter.staged_predict_proba">
<code class="descname">staged_predict_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/rep/metaml/stacking.html#FeatureSplitter.staged_predict_proba"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#rep.metaml.stacking.FeatureSplitter.staged_predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities after each stage of base classifier.
Each event will be predicted by the classifier</p>
<blockquote>
<div>with trained on corresponding value of <cite>split_feature</cite></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>X</strong> &#8211; pandas.DataFrame of shape [n_samples, n_features]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">iterable sequence of numpy.arrays of shape [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="report.html" class="btn btn-neutral float-right" title="Report for models" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="estimators.html" class="btn btn-neutral" title="Estimators (classification and regression)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2015, Yandex.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.6.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>